{
    "contents" : "#map.R\n#160825\n#Kiki Chang (ychang64@jhu.edu)\n#This file contains functions for creating village,township, and county map.\n#global vars: myDat, myMap, myLab, myVal, myColRange\n#local vars (part): filePath, colorNum, startVal, numInterval, width\n#----------------------------------------------------------------------------#\n\n#setwd(\"/Users/Kiki/Documents/縣市鄉鎮市區/\") #TODO: change the file path to this file's current location\n#import packages (If package is not installed, type install.packages(\"package name\"))\nlibrary(ggplot2)\nlibrary(gpclib)\nlibrary(tools)\nlibrary(xlsx)\nlibrary(xlsxjars)\nlibrary(rJava)\nlibrary(xlsxjars)\nlibrary(showtext)\nlibrary(RColorBrewer)\n\n#----------set graph color(s), startingValue, numInterval, and intervalWidth--------------#\n\n#[helper method] for user input choice [integer] (chooseColor(),setNumInterval());return TRUE if valid; FALSE otherwise.\n#max, min are inclusive (valid choice)\nuserChoice <- function(str, min, max) {\n  if(is.na(as.numeric(str))) {\n    message(paste(str, \"is not a numerical value.\"))\n    return(FALSE)\n  } else if (as.numeric(str)%%1 == 0) {\n    if(as.numeric(str) > max || as.numeric(str) < min) {\n      message(paste(str, \" is not in between \",min, \" and \", max, \".\", sep = \"\" ))\n      return(FALSE)\n    } else {\n      return(TRUE)\n    }\n  } else {\n    message(paste(str, \"is not an integer.\"))\n    return(FALSE)\n  }\n}\n#ask user for starting value; return starting value[numeric].\nsetStartVal <- function() {\n  start <- readline(prompt = \"What is the start value for this graph? Enter a number or type quit() to exit (default = 0): \")\n  if(is.na(as.numeric(start))) {\n    message(start, \" is not a numerical value.\")\n    return(setStartVal())\n  } else {\n    return(as.numeric(start))\n  }\n}\n#ask user for number of intervals(1-8); return number of intervals[numeric].\nsetNumInterval <- function() {\n  numIvl <- readline(prompt = \"How many intervals are in this graph? Enter an integer between 1-8 or type quit() to exit: \")\n  if(userChoice(numIvl,1,8)) {\n    return(as.numeric(numIvl))\n  } else {\n    return(setNumInterval())\n  }\n}\n#ask user for interval width; return interval width[numeric].\nsetIntervalWidth <- function() {\n  ivlWidth <- readline(prompt = \"What is the interval width for this graph? Enter a positive number or type quit() to exit: \")\n  if(is.na(as.numeric(ivlWidth))) {\n    message(ivlWidth, \" is not a numerical value.\")\n    return(setIntervalWidth())\n  } else if (as.numeric(ivlWidth) < 0) {\n    message(ivlWidth, \" is not a positive number.\")\n    return(setIntervalWidth())\n  } else {\n    return(as.numeric(ivlWidth))\n  }\n}\n#ask user for graph color;return the corresponding number(s)[numeric] of the color(s) for the graph.\nchooseColor <- function() {\n  message(\"choose 1 or 2 colors for the graph: (1)紅 (2)橘 (3)綠 (4)藍 (5)紫 (6)灰\\n (if choose 2 colors, numbers should be seperated by space)\")\n  color <- readline(prompt = \"enter the number or type quit() to exit: \")\n  color <- strsplit(color, split = \" \")[[1]]\n  if (length(color) == 1) {\n    if(userChoice(color, 1,7)) {\n      return(as.numeric(color))\n    }\n  } else if (length(color) == 2) {\n    if(userChoice(color[1],1,7) && userChoice(color[2],1,7)) {\n      return(as.numeric(color))\n    }\n  } else {\n    return(graphColor())\n  }\n}\n\n#---------------------------set data range and graph label--------------------------------#\n\n#sort data for single hue using defined starting value, width, and number of intervals; return myColRange.\n#no range is assigned if data == starting value.\nsetSgColRange <- function(numIvl, width, startVal=0) {\n  colRange <- c(NA)\n  for(i in 1:length(myVal)) {\n    if(!is.na(myVal[i])) { #if village myVal[i]'s data is not empty\n      for(j in (0:(numIvl-1))) { #every range besides the last one, which is inclusive\n        if(myVal[i] < width*j+ startVal) {\n          colRange[i] <- (j+1)\n          break\n        }\n      }\n      if(myVal[i] > (width*(numIvl-1)+ startVal) && myVal[i] <= (width*numIvl + startVal)) {  # smaller or equal to max AND greater than the previous range \n        colRange[i] <- (numIvl+1)\n      } else if (myVal[i] > (width*numIvl + startVal)) { #greater than max\n        colRange[i] <- (numIvl+2)\n      }\n    }\n  }\n  assign(\"myColRange\", colRange, envir = .GlobalEnv)\n}\n#sort data for two colors using defined starting value, width, and number of intervals; return myColRange.\n#number of interval is defined for each color; no range is assigned if data == starting value.\nsetDbColRange <- function(numIvl, width, startVal=0) {\n  colRange <- c(NA)\n  numColRange <- ((numIvl+1)*2)\n  for(i in 1:length(myVal)) {\n    f <- 0\n    k <- 0\n    if(!is.na(myVal[i])) { #not empty\n      if (myVal[i] > startVal) {  #  > startVal\n        if (myVal[i] > (width*numIvl + startVal)) { #greater than max\n          colRange[i] <- 1\n        } else if (myVal[i] > (width*(numIvl-1)+ startVal) && myVal[i] <= (width*numIvl + startVal)) {  #smaller or equal to max AND greater than the previous range \n          colRange[i] <- 2\n        } else if (numIvl > 1) {  #for loops\n          for(j in (1:(numIvl-1))) { #every range besides the last two edge cases\n            if(myVal[i] < (width*j+ startVal)) {\n              colRange[i] <- ((numIvl+1) - f)\n              break\n            }\n            f <- (f+1)\n          }\n        }\n      } else if (myVal[i] < startVal) {  # < startVal\n        if (myVal[i] < ((-width)*(numIvl) + startVal)) { #smaller than min\n          colRange[i] <- numColRange\n        } else if (myVal[i] < ((-width)*(numIvl-1)+ startVal) && myVal[i] >= ((-width)*numIvl + startVal)) {\n          colRange[i] <- (numColRange-1)\n        } else if (numIvl > 1) {\n          for(j in ((numIvl-1):1)) { #every range besides the last one, which is inclusive\n            if(myVal[i] > ((-width)*j+ startVal)) {\n              colRange[i] <- (numIvl*2 - k)\n              break\n            }\n            k <- (k+1) \n          }\n        }\n      }\n    }\n  }\n  assign(\"myColRange\", colRange, envir = .GlobalEnv)\n}\n#create the label for legends; @param numDigit max. number of digits (default = 4); \n#@param isPercent(bool) data is in percent form (default = TRUE); return myLab.\nsetLabel <- function(colorNum, numIvl,width, startVal = 0, isPercent = TRUE, numDigit = 4) {\n  #lab <- NA\n  if (length(colorNum) == 1) { #single color\n    sequence = seq(from = startVal, to = numIvl*width + startVal, by = width)\n    lab2 <- as.character(signif(sequence, digits = numDigit))\n    lab1 <- as.character(signif((sequence-width), digits = numDigit))\n    if (isPercent) {\n      lab <- paste(lab1, \"% ~ \",lab2, \"%\", sep = \"\")\n      lab[1] <- paste(\"< \", lab2[1], \"%\", sep = \"\")\n      lab[length(lab)+1] <- paste(\"> \", lab2[length(lab2)], \"%\", sep = \"\")\n    } else {\n      lab <- paste(lab1, \" ~ \",lab2, sep = \"\")\n      lab[1] <- paste(\"< \", lab2[1], sep = \"\")\n      lab[length(lab)+1] <- paste(\"> \", lab2[length(lab2)], sep = \"\")\n    }\n  } else { #two colors \n    sequence = seq(from = startVal, to = numIvl*width + startVal, by = width)\n    lab2 = sequence[2:length(sequence)]\n    lab2[length(lab2)+1] = lab2[length(lab2)]\n    lab2s = c(rev(lab2), startVal, -lab2)\n    lab2s = signif(lab2s, digits = numDigit)  #-lab2s is the same as rev(lab2s)\n    \n    lab1 = sequence[1:length(sequence)-1]\n    lab1[length(lab1)+1] = lab1[length(lab1)]\n    lab1s = c(rev(lab1), startVal, -lab1) \n    lab1s = signif(lab1s, digits = numDigit)\n    if(isPercent) {\n      lab <- paste(lab1s, \"% ~ \", lab2s, \"%\", sep = \"\")\n      lab[1] <- paste(\"> \", lab2s[1], \"%\", sep = \"\")\n      lab[length(lab)] <- paste(\"< \", lab2s[length(lab2s)], \"%\", sep = \"\")\n      lab[numIvl+2] <- paste(lab2s[numIvl+2], \"%\", sep = \"\")\n    } else {\n      lab <- paste(lab1s, \" ~ \", lab2s, sep = \"\")\n      lab[1] <- paste(\"> \", lab2s[1], sep = \"\")\n      lab[length(lab)] <- paste(\"< \", lab2s[length(lab2s)], sep = \"\")\n      lab[numIvl+2] <- paste(lab2s[numIvl+2], sep = \"\")\n    }\n  }\n  assign(\"myLab\", lab, envir = .GlobalEnv)\n}\n\n#--------------------------select data file and graph map----------------------------------#\n\n#ask user for data; eliminate rows with NAs; create a list (myDat) containing graph title and data.\nchooseFile <- function(filePath) {\n  fp <- strsplit(basename(filePath), \"[.]\")[[1]]\n  if (fp[2] == \"csv\") {\n    dat <- read.csv(filePath, header = TRUE, stringsAsFactors=FALSE)\n    dat <- dat[complete.cases(dat),]\n    dat <- list(fp[1], dat) \n  } else if (fp[2] == \"xlsx\") {\n    dat <- read.xlsx(filePath,1, header = TRUE, stringsAsFactors=FALSE)\n    dat <- dat[complete.cases(dat),]\n    dat <- list(fp[1], dat) #remove rows w/ NAs \n  } else {\n    warning(\"please import a csv/xlsx file\")\n  }\n  assign(\"myDat\", dat, envir = .GlobalEnv)\n}\n#graph data to the corresponding area; area without data are graphed using grey40 (dark grey).\n#@param showName(bool) determines if area names are shown on graph; @param legendName(string) legend shown on graph; @param ext(string) file extension.\n#@param textSize(numeric) size of the area name. @param isVillage(bool) set TRUE if graphing village map (default = FALSE)\n#file extensions can be: eps/ps, tex (pictex), pdf, jpeg, tiff, png, bmp, svg and wmf (windows only).\ngraphArea <- function(colorNum, numInterval,legendName = \"得票率\", isVillage = FALSE, textSize = 3, ext = \".svg\", showName = TRUE) {\n  myFrame <- fortify(myMap)\n  names(myFrame)[1:2] = c(\"x\",\"y\")\n  \n  ids <- as.numeric(unique(myFrame$id))\n  myGraph <- data.frame(id = ids)  #hard code would be myGraph <- data.frame(id = c(0:22))\n  myGraph$val <- myVal\n  myGraph$range <-myColRange\n  \n#   #area names\n#   area <- as.data.frame(coordinates(myMap))\n#   area$names <- unique(myMap$countyname)\n  \n  showtext.auto(enable = TRUE)\n  font.add(\"HuaWen\",\"华文细黑.ttf\")\n  \n  #graph\n  img = ggplot(myGraph) +\n    geom_map(aes(map_id = id, fill = factor(range)), color = \"white\", map = myFrame) + coord_map() + \n    labs(x= NULL, y = NULL, title = myDat[[1]]) + guides(fill = guide_legend(nrow = length(myLab))) +\n    theme(axis.text = element_blank(), axis.ticks = element_blank(), panel.grid = element_blank(), text = element_text(family = 'HuaWen'))\n  \n  #if(!exists(\"myArea\")) {\n  if(isVillage) {\n    myArea <- as.data.frame(coordinates(myMap))\n    myArea$names <- unique(myMap$V_Name)  \n  }\n  \n  #display area names on graph\n  if (showName) {\n    img = img + geom_text(size = textSize , aes(x=V1, y= V2, label = names), data = myArea)\n  }\n  \n  #set colors\n  if (length(colorNum) == 1) {\n    pal <- switch(colorNum, \"Reds\", \"Oranges\", \"Greens\", \"Blues\", \"Purples\",\"Greys\")\n    img = img + scale_fill_brewer(palette = pal, drop = FALSE, name = legendName,  na.value = \"grey40\", limits = c(as.character(1:length(myLab))), labels = myLab)\n  } else {\n    pal1 <- switch(colorNum[1], \"Reds\", \"Oranges\", \"Greens\", \"Blues\", \"Purples\",\"Greys\")\n    pal2 <- switch(colorNum[2], \"Reds\", \"Oranges\", \"Greens\", \"Blues\", \"Purples\",\"Greys\")\n    twoPal <-c(rev(brewer.pal(numInterval+1, pal1)), \"grey90\", brewer.pal(numInterval+1, pal2))\n    img = img + scale_fill_manual(values = twoPal, drop = FALSE, name = legendName, na.value = \"grey40\", limits = c(as.character(1:length(myLab))), labels = myLab)\n  }\n  \n  if (isVillage) {\n    maxX <- as.numeric(max(myFrame$x)) #get width & length of the graph\n    minX <- as.numeric(min(myFrame$x))\n    maxY <- as.numeric(max(myFrame$y))\n    minY <- as.numeric(min(myFrame$y))\n    img = img + expand_limits(x=c(minX,maxX), y=c(minY,maxY))\n  } else {\n    img = img + expand_limits(x=c(119.75,122.25), y=c(22,25.5))\n  }\n  imgName <-paste(myDat[[1]], ext, sep= \"\")\n  ggsave(filename = imgName, plot=img)\n}\n\n#------------------store village, township, county data from file-------------------------#\n\n#store data to the corresponding village; invalid area color would be dark grey (grey40); return myVal.\nstoreVillageData <- function() {\n  vals <- c()\n  for (i in 1:length(myMap$VILLAGE_ID)) {\n    n <- grep(myMap$V_Name[i], myDat[[2]][,1])\n    if (length(n) != 0) {\n      if (length(n) == 1) {\n        vals[i] <- myDat[[2]][n,2]\n      } else if (length(n) > 1) {  #multiple values found for one village in the data\n        message(\"multiple values for \", myMap$V_Name[i], \" (stored the first found)\")\n        vals[i] <- myDat[[2]][n[1],2]\n      }\n    } else if ((grepl(\"[1-9]\", myMap$V_Name[i]))) { #if V_Name contains numerical values (e.g. 黃官嶼2)\n      vlg <- strsplit(myMap$V_name[i], \"[1-9]\")[[1]]\n      n <- grep(vlg, myDat[[2]][,1])\n      if (length(n) == 1) {\n        vals[i] <- myDat[[2]][n,2]\n      } else if (length(n) > 1) {  #multiple values found for one village in the data\n        message(\"multiple values for \", myMap$V_Name[i], \" (stored the first found)\")\n        vals[i] <- myDat[[2]][n[1],2]\n      }\n    } else { #look for alternative village name\n      n <- grep(myMap$Substitute[i], myDat[[2]][,1])\n      if (length(n) == 1) {\n        vals[i] <- myDat[[2]][n,2]\n      } else if (length(n) > 1) {  #multiple values found for one village in the data\n        message(\"multiple values for \", myMap$V_Name[i], \" (stored the first found)\")\n        vals[i] <- myDat[[2]][n[1],2]\n      } else {\n        message(\"data not found for \", myMap$V_Name[i])\n      }\n    }\n  }\n  assign(\"myVal\", vals, envir = .GlobalEnv)\n}\n#store data to the corresponding town; invalid area color would be dark grey (grey40); return myVal.\nstoreTownData <- function() {\n  vals <- c()\n  for(i in 1:length(myMap$townid)) {\n    n <- intersect(grep(myMap$townname[i], myDat[[2]][,2]), grep(myMap$countyname[i], myDat[[2]][,1]))\n    if (length(n) == 1) {\n      vals[i] <- myDat[[2]][n,3]\n    } else if(length(n) > 1) {\n      message(\"multiple values for \", myMap$countyname[i], myMap$townname[i], \"(stored the first found)\")\n      vals[i] <- myDat[[2]][n[1],3]\n    } else if (grepl(\"(海)\", myMap$townname[i])) {  #TODO: need to check for if myMap$countyname[i] exists as well? (prob not)\n      ctyName <- strsplit(myMap$countyname[i], '[(海)]')[[1]]\n      twnName <- strsplit(myMap$townname[i], '[(海)]')[[1]]\n      n <- intersect(grep(twnName[1], myDat2[,2]), grep(ctyName[1], myDat[[2]][,1]))\n      if(length(n) == 1) {\n        vals[i] <- myDat[[2]][n,3]\n      } else if (length(n) > 1) {\n        message(\"multiple values for \", ctyName[1], twnName[1], \"(stored the first found)\", sep = \"\")\n        vals[i] <- myDat[[2]][n[1],3]\n      } else {\n        message(\"data not found for \", ctyName[1], twnName[1])\n      }\n    } else {\n      message(\"data not found for \", myMap$countyname[i], myMap$townname[i])\n    }\n  }\n  assign(\"myVal\", vals, envir = .GlobalEnv)\n}\n#store data to the corresponding county; invalid area color would be dark grey (grey40); return myVal.\nstoreCountyData <- function() {\n  vals <- c()\n  for (i in 1:length(myMap$countyid)) {\n    n <- grep(myMap$countyname[i], myDat[[2]][,1])\n    if (length(n) == 1) {\n      vals[i] <- myDat[[2]][n,2]\n    } else if (length(n) > 1) {\n      message(\"multiple values for \", myMap$countyname[i], \" (stored the first found)\")\n      vals[i] <- myDat[[2]][n[1],2]\n    } else if (grepl(\"(海)\", myMap$countyname[i])) { #基隆市(海),台中市(海),台南市(海), 高雄市(海)\n      vals[i] <- vals[i-1]\n    } else {\n      message(\"data not found for \", myMap$countyname[i])\n    }\n  }\n  assign(\"myVal\",vals, envir = .GlobalEnv)\n}\n\n#------------------menu for villageMapDriver-------------------------#\n#ask user for county; return county number(numeric)\nctyMenu <- function() {\n  message(paste(\"Which county/county of the respective district do you want to graph? \\n\", ctyQ, sep=\"\"))\n  cityNumber <- readline(prompt = \"enter the number or type quit() to exit: \")\n  if(userChoice(cityNumber,1,22)) {\n    return(as.numeric(cityNumber))\n  } else {\n    return(ctyMenu())\n  }\n}\n#ask user for district; param: county number; return district name(string)\ndstMenu <- function(ctyNum) {\n  message(paste(\"Which district do you want to graph? \\n\", allDstQ[ctyNum], sep=\"\"))\n  dstNum <- readline(prompt = \"enter the number type quit() to exit: \")\n  max <- subset(allNames, allNames$myMap.C_Name == ctyNames[ctyNum])\n  if(userChoice(dstNum,1,length(unique(max$myMap.T_Name)))) {\n    dstName <- (strsplit(allDstQ[ctyNum], \" \")[[1]])[as.numeric(dstNum)*2]\n    return(dstName) \n  } else {\n    return(dstMenu(ctyNum))\n  }\n}",
    "created" : 1472583519666.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2555059194",
    "id" : "EC46CE43",
    "lastKnownWriteTime" : 1472364274,
    "path" : "~/Dropbox/Kiki-project/map.R",
    "project_path" : "map.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}